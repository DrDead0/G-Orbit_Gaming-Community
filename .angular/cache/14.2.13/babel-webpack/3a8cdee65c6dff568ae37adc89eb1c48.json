{"ast":null,"code":"import _asyncToGenerator from \"D:/Gamer`s Orbit/clips/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { _getProvider, getApp, _registerComponent, registerVersion, SDK_VERSION } from '@firebase/app';\nimport { ErrorFactory, FirebaseError, getModularInstance, calculateBackoffMillis, isIndexedDBAvailable, validateIndexedDBOpenable } from '@firebase/util';\nimport { Component } from '@firebase/component';\nimport { LogLevel, Logger } from '@firebase/logger';\nimport '@firebase/installations';\nconst name = \"@firebase/remote-config\";\nconst version = \"0.4.4\";\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * Shims a minimal AbortSignal.\r\n *\r\n * <p>AbortController's AbortSignal conveniently decouples fetch timeout logic from other aspects\r\n * of networking, such as retries. Firebase doesn't use AbortController enough to justify a\r\n * polyfill recommendation, like we do with the Fetch API, but this minimal shim can easily be\r\n * swapped out if/when we do.\r\n */\n\nclass RemoteConfigAbortSignal {\n  constructor() {\n    this.listeners = [];\n  }\n\n  addEventListener(listener) {\n    this.listeners.push(listener);\n  }\n\n  abort() {\n    this.listeners.forEach(listener => listener());\n  }\n\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nconst RC_COMPONENT_NAME = 'remote-config';\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nconst ERROR_DESCRIPTION_MAP = {\n  [\"registration-window\"\n  /* ErrorCode.REGISTRATION_WINDOW */\n  ]: 'Undefined window object. This SDK only supports usage in a browser environment.',\n  [\"registration-project-id\"\n  /* ErrorCode.REGISTRATION_PROJECT_ID */\n  ]: 'Undefined project identifier. Check Firebase app initialization.',\n  [\"registration-api-key\"\n  /* ErrorCode.REGISTRATION_API_KEY */\n  ]: 'Undefined API key. Check Firebase app initialization.',\n  [\"registration-app-id\"\n  /* ErrorCode.REGISTRATION_APP_ID */\n  ]: 'Undefined app identifier. Check Firebase app initialization.',\n  [\"storage-open\"\n  /* ErrorCode.STORAGE_OPEN */\n  ]: 'Error thrown when opening storage. Original error: {$originalErrorMessage}.',\n  [\"storage-get\"\n  /* ErrorCode.STORAGE_GET */\n  ]: 'Error thrown when reading from storage. Original error: {$originalErrorMessage}.',\n  [\"storage-set\"\n  /* ErrorCode.STORAGE_SET */\n  ]: 'Error thrown when writing to storage. Original error: {$originalErrorMessage}.',\n  [\"storage-delete\"\n  /* ErrorCode.STORAGE_DELETE */\n  ]: 'Error thrown when deleting from storage. Original error: {$originalErrorMessage}.',\n  [\"fetch-client-network\"\n  /* ErrorCode.FETCH_NETWORK */\n  ]: 'Fetch client failed to connect to a network. Check Internet connection.' + ' Original error: {$originalErrorMessage}.',\n  [\"fetch-timeout\"\n  /* ErrorCode.FETCH_TIMEOUT */\n  ]: 'The config fetch request timed out. ' + ' Configure timeout using \"fetchTimeoutMillis\" SDK setting.',\n  [\"fetch-throttle\"\n  /* ErrorCode.FETCH_THROTTLE */\n  ]: 'The config fetch request timed out while in an exponential backoff state.' + ' Configure timeout using \"fetchTimeoutMillis\" SDK setting.' + ' Unix timestamp in milliseconds when fetch request throttling ends: {$throttleEndTimeMillis}.',\n  [\"fetch-client-parse\"\n  /* ErrorCode.FETCH_PARSE */\n  ]: 'Fetch client could not parse response.' + ' Original error: {$originalErrorMessage}.',\n  [\"fetch-status\"\n  /* ErrorCode.FETCH_STATUS */\n  ]: 'Fetch server returned an HTTP error status. HTTP status: {$httpStatus}.',\n  [\"indexed-db-unavailable\"\n  /* ErrorCode.INDEXED_DB_UNAVAILABLE */\n  ]: 'Indexed DB is not supported by current browser'\n};\nconst ERROR_FACTORY = new ErrorFactory('remoteconfig'\n/* service */\n, 'Remote Config'\n/* service name */\n, ERROR_DESCRIPTION_MAP); // Note how this is like typeof/instanceof, but for ErrorCode.\n\nfunction hasErrorCode(e, errorCode) {\n  return e instanceof FirebaseError && e.code.indexOf(errorCode) !== -1;\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nconst DEFAULT_VALUE_FOR_BOOLEAN = false;\nconst DEFAULT_VALUE_FOR_STRING = '';\nconst DEFAULT_VALUE_FOR_NUMBER = 0;\nconst BOOLEAN_TRUTHY_VALUES = ['1', 'true', 't', 'yes', 'y', 'on'];\n\nclass Value {\n  constructor(_source, _value = DEFAULT_VALUE_FOR_STRING) {\n    this._source = _source;\n    this._value = _value;\n  }\n\n  asString() {\n    return this._value;\n  }\n\n  asBoolean() {\n    if (this._source === 'static') {\n      return DEFAULT_VALUE_FOR_BOOLEAN;\n    }\n\n    return BOOLEAN_TRUTHY_VALUES.indexOf(this._value.toLowerCase()) >= 0;\n  }\n\n  asNumber() {\n    if (this._source === 'static') {\n      return DEFAULT_VALUE_FOR_NUMBER;\n    }\n\n    let num = Number(this._value);\n\n    if (isNaN(num)) {\n      num = DEFAULT_VALUE_FOR_NUMBER;\n    }\n\n    return num;\n  }\n\n  getSource() {\n    return this._source;\n  }\n\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n *\r\n * @param app - The {@link @firebase/app#FirebaseApp} instance.\r\n * @returns A {@link RemoteConfig} instance.\r\n *\r\n * @public\r\n */\n\n\nfunction getRemoteConfig(app = getApp()) {\n  app = getModularInstance(app);\n\n  const rcProvider = _getProvider(app, RC_COMPONENT_NAME);\n\n  return rcProvider.getImmediate();\n}\n/**\r\n * Makes the last fetched config available to the getters.\r\n * @param remoteConfig - The {@link RemoteConfig} instance.\r\n * @returns A `Promise` which resolves to true if the current call activated the fetched configs.\r\n * If the fetched configs were already activated, the `Promise` will resolve to false.\r\n *\r\n * @public\r\n */\n\n\nfunction activate(_x) {\n  return _activate.apply(this, arguments);\n}\n/**\r\n * Ensures the last activated config are available to the getters.\r\n * @param remoteConfig - The {@link RemoteConfig} instance.\r\n *\r\n * @returns A `Promise` that resolves when the last activated config is available to the getters.\r\n * @public\r\n */\n\n\nfunction _activate() {\n  _activate = _asyncToGenerator(function* (remoteConfig) {\n    const rc = getModularInstance(remoteConfig);\n    const [lastSuccessfulFetchResponse, activeConfigEtag] = yield Promise.all([rc._storage.getLastSuccessfulFetchResponse(), rc._storage.getActiveConfigEtag()]);\n\n    if (!lastSuccessfulFetchResponse || !lastSuccessfulFetchResponse.config || !lastSuccessfulFetchResponse.eTag || lastSuccessfulFetchResponse.eTag === activeConfigEtag) {\n      // Either there is no successful fetched config, or is the same as current active\n      // config.\n      return false;\n    }\n\n    yield Promise.all([rc._storageCache.setActiveConfig(lastSuccessfulFetchResponse.config), rc._storage.setActiveConfigEtag(lastSuccessfulFetchResponse.eTag)]);\n    return true;\n  });\n  return _activate.apply(this, arguments);\n}\n\nfunction ensureInitialized(remoteConfig) {\n  const rc = getModularInstance(remoteConfig);\n\n  if (!rc._initializePromise) {\n    rc._initializePromise = rc._storageCache.loadFromStorage().then(() => {\n      rc._isInitializationComplete = true;\n    });\n  }\n\n  return rc._initializePromise;\n}\n/**\r\n * Fetches and caches configuration from the Remote Config service.\r\n * @param remoteConfig - The {@link RemoteConfig} instance.\r\n * @public\r\n */\n\n\nfunction fetchConfig(_x2) {\n  return _fetchConfig.apply(this, arguments);\n}\n/**\r\n * Gets all config.\r\n *\r\n * @param remoteConfig - The {@link RemoteConfig} instance.\r\n * @returns All config.\r\n *\r\n * @public\r\n */\n\n\nfunction _fetchConfig() {\n  _fetchConfig = _asyncToGenerator(function* (remoteConfig) {\n    const rc = getModularInstance(remoteConfig); // Aborts the request after the given timeout, causing the fetch call to\n    // reject with an `AbortError`.\n    //\n    // <p>Aborting after the request completes is a no-op, so we don't need a\n    // corresponding `clearTimeout`.\n    //\n    // Locating abort logic here because:\n    // * it uses a developer setting (timeout)\n    // * it applies to all retries (like curl's max-time arg)\n    // * it is consistent with the Fetch API's signal input\n\n    const abortSignal = new RemoteConfigAbortSignal();\n    setTimeout( /*#__PURE__*/_asyncToGenerator(function* () {\n      // Note a very low delay, eg < 10ms, can elapse before listeners are initialized.\n      abortSignal.abort();\n    }), rc.settings.fetchTimeoutMillis); // Catches *all* errors thrown by client so status can be set consistently.\n\n    try {\n      yield rc._client.fetch({\n        cacheMaxAgeMillis: rc.settings.minimumFetchIntervalMillis,\n        signal: abortSignal\n      });\n      yield rc._storageCache.setLastFetchStatus('success');\n    } catch (e) {\n      const lastFetchStatus = hasErrorCode(e, \"fetch-throttle\"\n      /* ErrorCode.FETCH_THROTTLE */\n      ) ? 'throttle' : 'failure';\n      yield rc._storageCache.setLastFetchStatus(lastFetchStatus);\n      throw e;\n    }\n  });\n  return _fetchConfig.apply(this, arguments);\n}\n\nfunction getAll(remoteConfig) {\n  const rc = getModularInstance(remoteConfig);\n  return getAllKeys(rc._storageCache.getActiveConfig(), rc.defaultConfig).reduce((allConfigs, key) => {\n    allConfigs[key] = getValue(remoteConfig, key);\n    return allConfigs;\n  }, {});\n}\n/**\r\n * Gets the value for the given key as a boolean.\r\n *\r\n * Convenience method for calling <code>remoteConfig.getValue(key).asBoolean()</code>.\r\n *\r\n * @param remoteConfig - The {@link RemoteConfig} instance.\r\n * @param key - The name of the parameter.\r\n *\r\n * @returns The value for the given key as a boolean.\r\n * @public\r\n */\n\n\nfunction getBoolean(remoteConfig, key) {\n  return getValue(getModularInstance(remoteConfig), key).asBoolean();\n}\n/**\r\n * Gets the value for the given key as a number.\r\n *\r\n * Convenience method for calling <code>remoteConfig.getValue(key).asNumber()</code>.\r\n *\r\n * @param remoteConfig - The {@link RemoteConfig} instance.\r\n * @param key - The name of the parameter.\r\n *\r\n * @returns The value for the given key as a number.\r\n *\r\n * @public\r\n */\n\n\nfunction getNumber(remoteConfig, key) {\n  return getValue(getModularInstance(remoteConfig), key).asNumber();\n}\n/**\r\n * Gets the value for the given key as a string.\r\n * Convenience method for calling <code>remoteConfig.getValue(key).asString()</code>.\r\n *\r\n * @param remoteConfig - The {@link RemoteConfig} instance.\r\n * @param key - The name of the parameter.\r\n *\r\n * @returns The value for the given key as a string.\r\n *\r\n * @public\r\n */\n\n\nfunction getString(remoteConfig, key) {\n  return getValue(getModularInstance(remoteConfig), key).asString();\n}\n/**\r\n * Gets the {@link Value} for the given key.\r\n *\r\n * @param remoteConfig - The {@link RemoteConfig} instance.\r\n * @param key - The name of the parameter.\r\n *\r\n * @returns The value for the given key.\r\n *\r\n * @public\r\n */\n\n\nfunction getValue(remoteConfig, key) {\n  const rc = getModularInstance(remoteConfig);\n\n  if (!rc._isInitializationComplete) {\n    rc._logger.debug(`A value was requested for key \"${key}\" before SDK initialization completed.` + ' Await on ensureInitialized if the intent was to get a previously activated value.');\n  }\n\n  const activeConfig = rc._storageCache.getActiveConfig();\n\n  if (activeConfig && activeConfig[key] !== undefined) {\n    return new Value('remote', activeConfig[key]);\n  } else if (rc.defaultConfig && rc.defaultConfig[key] !== undefined) {\n    return new Value('default', String(rc.defaultConfig[key]));\n  }\n\n  rc._logger.debug(`Returning static value for key \"${key}\".` + ' Define a default or remote value if this is unintentional.');\n\n  return new Value('static');\n}\n/**\r\n * Defines the log level to use.\r\n *\r\n * @param remoteConfig - The {@link RemoteConfig} instance.\r\n * @param logLevel - The log level to set.\r\n *\r\n * @public\r\n */\n\n\nfunction setLogLevel(remoteConfig, logLevel) {\n  const rc = getModularInstance(remoteConfig);\n\n  switch (logLevel) {\n    case 'debug':\n      rc._logger.logLevel = LogLevel.DEBUG;\n      break;\n\n    case 'silent':\n      rc._logger.logLevel = LogLevel.SILENT;\n      break;\n\n    default:\n      rc._logger.logLevel = LogLevel.ERROR;\n  }\n}\n/**\r\n * Dedupes and returns an array of all the keys of the received objects.\r\n */\n\n\nfunction getAllKeys(obj1 = {}, obj2 = {}) {\n  return Object.keys(Object.assign(Object.assign({}, obj1), obj2));\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * Implements the {@link RemoteConfigClient} abstraction with success response caching.\r\n *\r\n * <p>Comparable to the browser's Cache API for responses, but the Cache API requires a Service\r\n * Worker, which requires HTTPS, which would significantly complicate SDK installation. Also, the\r\n * Cache API doesn't support matching entries by time.\r\n */\n\n\nclass CachingClient {\n  constructor(client, storage, storageCache, logger) {\n    this.client = client;\n    this.storage = storage;\n    this.storageCache = storageCache;\n    this.logger = logger;\n  }\n  /**\r\n   * Returns true if the age of the cached fetched configs is less than or equal to\r\n   * {@link Settings#minimumFetchIntervalInSeconds}.\r\n   *\r\n   * <p>This is comparable to passing `headers = { 'Cache-Control': max-age <maxAge> }` to the\r\n   * native Fetch API.\r\n   *\r\n   * <p>Visible for testing.\r\n   */\n\n\n  isCachedDataFresh(cacheMaxAgeMillis, lastSuccessfulFetchTimestampMillis) {\n    // Cache can only be fresh if it's populated.\n    if (!lastSuccessfulFetchTimestampMillis) {\n      this.logger.debug('Config fetch cache check. Cache unpopulated.');\n      return false;\n    } // Calculates age of cache entry.\n\n\n    const cacheAgeMillis = Date.now() - lastSuccessfulFetchTimestampMillis;\n    const isCachedDataFresh = cacheAgeMillis <= cacheMaxAgeMillis;\n    this.logger.debug('Config fetch cache check.' + ` Cache age millis: ${cacheAgeMillis}.` + ` Cache max age millis (minimumFetchIntervalMillis setting): ${cacheMaxAgeMillis}.` + ` Is cache hit: ${isCachedDataFresh}.`);\n    return isCachedDataFresh;\n  }\n\n  fetch(request) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      // Reads from persisted storage to avoid cache miss if callers don't wait on initialization.\n      const [lastSuccessfulFetchTimestampMillis, lastSuccessfulFetchResponse] = yield Promise.all([_this.storage.getLastSuccessfulFetchTimestampMillis(), _this.storage.getLastSuccessfulFetchResponse()]); // Exits early on cache hit.\n\n      if (lastSuccessfulFetchResponse && _this.isCachedDataFresh(request.cacheMaxAgeMillis, lastSuccessfulFetchTimestampMillis)) {\n        return lastSuccessfulFetchResponse;\n      } // Deviates from pure decorator by not honoring a passed ETag since we don't have a public API\n      // that allows the caller to pass an ETag.\n\n\n      request.eTag = lastSuccessfulFetchResponse && lastSuccessfulFetchResponse.eTag; // Falls back to service on cache miss.\n\n      const response = yield _this.client.fetch(request); // Fetch throws for non-success responses, so success is guaranteed here.\n\n      const storageOperations = [// Uses write-through cache for consistency with synchronous public API.\n      _this.storageCache.setLastSuccessfulFetchTimestampMillis(Date.now())];\n\n      if (response.status === 200) {\n        // Caches response only if it has changed, ie non-304 responses.\n        storageOperations.push(_this.storage.setLastSuccessfulFetchResponse(response));\n      }\n\n      yield Promise.all(storageOperations);\n      return response;\n    })();\n  }\n\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * Attempts to get the most accurate browser language setting.\r\n *\r\n * <p>Adapted from getUserLanguage in packages/auth/src/utils.js for TypeScript.\r\n *\r\n * <p>Defers default language specification to server logic for consistency.\r\n *\r\n * @param navigatorLanguage Enables tests to override read-only {@link NavigatorLanguage}.\r\n */\n\n\nfunction getUserLanguage(navigatorLanguage = navigator) {\n  return (// Most reliable, but only supported in Chrome/Firefox.\n    navigatorLanguage.languages && navigatorLanguage.languages[0] || // Supported in most browsers, but returns the language of the browser\n    // UI, not the language set in browser settings.\n    navigatorLanguage.language // Polyfill otherwise.\n\n  );\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * Implements the Client abstraction for the Remote Config REST API.\r\n */\n\n\nclass RestClient {\n  constructor(firebaseInstallations, sdkVersion, namespace, projectId, apiKey, appId) {\n    this.firebaseInstallations = firebaseInstallations;\n    this.sdkVersion = sdkVersion;\n    this.namespace = namespace;\n    this.projectId = projectId;\n    this.apiKey = apiKey;\n    this.appId = appId;\n  }\n  /**\r\n   * Fetches from the Remote Config REST API.\r\n   *\r\n   * @throws a {@link ErrorCode.FETCH_NETWORK} error if {@link GlobalFetch#fetch} can't\r\n   * connect to the network.\r\n   * @throws a {@link ErrorCode.FETCH_PARSE} error if {@link Response#json} can't parse the\r\n   * fetch response.\r\n   * @throws a {@link ErrorCode.FETCH_STATUS} error if the service returns an HTTP error status.\r\n   */\n\n\n  fetch(request) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const [installationId, installationToken] = yield Promise.all([_this2.firebaseInstallations.getId(), _this2.firebaseInstallations.getToken()]);\n      const urlBase = window.FIREBASE_REMOTE_CONFIG_URL_BASE || 'https://firebaseremoteconfig.googleapis.com';\n      const url = `${urlBase}/v1/projects/${_this2.projectId}/namespaces/${_this2.namespace}:fetch?key=${_this2.apiKey}`;\n      const headers = {\n        'Content-Type': 'application/json',\n        'Content-Encoding': 'gzip',\n        // Deviates from pure decorator by not passing max-age header since we don't currently have\n        // service behavior using that header.\n        'If-None-Match': request.eTag || '*'\n      };\n      const requestBody = {\n        /* eslint-disable camelcase */\n        sdk_version: _this2.sdkVersion,\n        app_instance_id: installationId,\n        app_instance_id_token: installationToken,\n        app_id: _this2.appId,\n        language_code: getUserLanguage()\n        /* eslint-enable camelcase */\n\n      };\n      const options = {\n        method: 'POST',\n        headers,\n        body: JSON.stringify(requestBody)\n      }; // This logic isn't REST-specific, but shimming abort logic isn't worth another decorator.\n\n      const fetchPromise = fetch(url, options);\n      const timeoutPromise = new Promise((_resolve, reject) => {\n        // Maps async event listener to Promise API.\n        request.signal.addEventListener(() => {\n          // Emulates https://heycam.github.io/webidl/#aborterror\n          const error = new Error('The operation was aborted.');\n          error.name = 'AbortError';\n          reject(error);\n        });\n      });\n      let response;\n\n      try {\n        yield Promise.race([fetchPromise, timeoutPromise]);\n        response = yield fetchPromise;\n      } catch (originalError) {\n        let errorCode = \"fetch-client-network\"\n        /* ErrorCode.FETCH_NETWORK */\n        ;\n\n        if ((originalError === null || originalError === void 0 ? void 0 : originalError.name) === 'AbortError') {\n          errorCode = \"fetch-timeout\"\n          /* ErrorCode.FETCH_TIMEOUT */\n          ;\n        }\n\n        throw ERROR_FACTORY.create(errorCode, {\n          originalErrorMessage: originalError === null || originalError === void 0 ? void 0 : originalError.message\n        });\n      }\n\n      let status = response.status; // Normalizes nullable header to optional.\n\n      const responseEtag = response.headers.get('ETag') || undefined;\n      let config;\n      let state; // JSON parsing throws SyntaxError if the response body isn't a JSON string.\n      // Requesting application/json and checking for a 200 ensures there's JSON data.\n\n      if (response.status === 200) {\n        let responseBody;\n\n        try {\n          responseBody = yield response.json();\n        } catch (originalError) {\n          throw ERROR_FACTORY.create(\"fetch-client-parse\"\n          /* ErrorCode.FETCH_PARSE */\n          , {\n            originalErrorMessage: originalError === null || originalError === void 0 ? void 0 : originalError.message\n          });\n        }\n\n        config = responseBody['entries'];\n        state = responseBody['state'];\n      } // Normalizes based on legacy state.\n\n\n      if (state === 'INSTANCE_STATE_UNSPECIFIED') {\n        status = 500;\n      } else if (state === 'NO_CHANGE') {\n        status = 304;\n      } else if (state === 'NO_TEMPLATE' || state === 'EMPTY_CONFIG') {\n        // These cases can be fixed remotely, so normalize to safe value.\n        config = {};\n      } // Normalize to exception-based control flow for non-success cases.\n      // Encapsulates HTTP specifics in this class as much as possible. Status is still the best for\n      // differentiating success states (200 from 304; the state body param is undefined in a\n      // standard 304).\n\n\n      if (status !== 304 && status !== 200) {\n        throw ERROR_FACTORY.create(\"fetch-status\"\n        /* ErrorCode.FETCH_STATUS */\n        , {\n          httpStatus: status\n        });\n      }\n\n      return {\n        status,\n        eTag: responseEtag,\n        config\n      };\n    })();\n  }\n\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * Supports waiting on a backoff by:\r\n *\r\n * <ul>\r\n *   <li>Promisifying setTimeout, so we can set a timeout in our Promise chain</li>\r\n *   <li>Listening on a signal bus for abort events, just like the Fetch API</li>\r\n *   <li>Failing in the same way the Fetch API fails, so timing out a live request and a throttled\r\n *       request appear the same.</li>\r\n * </ul>\r\n *\r\n * <p>Visible for testing.\r\n */\n\n\nfunction setAbortableTimeout(signal, throttleEndTimeMillis) {\n  return new Promise((resolve, reject) => {\n    // Derives backoff from given end time, normalizing negative numbers to zero.\n    const backoffMillis = Math.max(throttleEndTimeMillis - Date.now(), 0);\n    const timeout = setTimeout(resolve, backoffMillis); // Adds listener, rather than sets onabort, because signal is a shared object.\n\n    signal.addEventListener(() => {\n      clearTimeout(timeout); // If the request completes before this timeout, the rejection has no effect.\n\n      reject(ERROR_FACTORY.create(\"fetch-throttle\"\n      /* ErrorCode.FETCH_THROTTLE */\n      , {\n        throttleEndTimeMillis\n      }));\n    });\n  });\n}\n/**\r\n * Returns true if the {@link Error} indicates a fetch request may succeed later.\r\n */\n\n\nfunction isRetriableError(e) {\n  if (!(e instanceof FirebaseError) || !e.customData) {\n    return false;\n  } // Uses string index defined by ErrorData, which FirebaseError implements.\n\n\n  const httpStatus = Number(e.customData['httpStatus']);\n  return httpStatus === 429 || httpStatus === 500 || httpStatus === 503 || httpStatus === 504;\n}\n/**\r\n * Decorates a Client with retry logic.\r\n *\r\n * <p>Comparable to CachingClient, but uses backoff logic instead of cache max age and doesn't cache\r\n * responses (because the SDK has no use for error responses).\r\n */\n\n\nclass RetryingClient {\n  constructor(client, storage) {\n    this.client = client;\n    this.storage = storage;\n  }\n\n  fetch(request) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const throttleMetadata = (yield _this3.storage.getThrottleMetadata()) || {\n        backoffCount: 0,\n        throttleEndTimeMillis: Date.now()\n      };\n      return _this3.attemptFetch(request, throttleMetadata);\n    })();\n  }\n  /**\r\n   * A recursive helper for attempting a fetch request repeatedly.\r\n   *\r\n   * @throws any non-retriable errors.\r\n   */\n\n\n  attemptFetch(request, {\n    throttleEndTimeMillis,\n    backoffCount\n  }) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      // Starts with a (potentially zero) timeout to support resumption from stored state.\n      // Ensures the throttle end time is honored if the last attempt timed out.\n      // Note the SDK will never make a request if the fetch timeout expires at this point.\n      yield setAbortableTimeout(request.signal, throttleEndTimeMillis);\n\n      try {\n        const response = yield _this4.client.fetch(request); // Note the SDK only clears throttle state if response is success or non-retriable.\n\n        yield _this4.storage.deleteThrottleMetadata();\n        return response;\n      } catch (e) {\n        if (!isRetriableError(e)) {\n          throw e;\n        } // Increments backoff state.\n\n\n        const throttleMetadata = {\n          throttleEndTimeMillis: Date.now() + calculateBackoffMillis(backoffCount),\n          backoffCount: backoffCount + 1\n        }; // Persists state.\n\n        yield _this4.storage.setThrottleMetadata(throttleMetadata);\n        return _this4.attemptFetch(request, throttleMetadata);\n      }\n    })();\n  }\n\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nconst DEFAULT_FETCH_TIMEOUT_MILLIS = 60 * 1000; // One minute\n\nconst DEFAULT_CACHE_MAX_AGE_MILLIS = 12 * 60 * 60 * 1000; // Twelve hours.\n\n/**\r\n * Encapsulates business logic mapping network and storage dependencies to the public SDK API.\r\n *\r\n * See {@link https://github.com/FirebasePrivate/firebase-js-sdk/blob/master/packages/firebase/index.d.ts|interface documentation} for method descriptions.\r\n */\n\nclass RemoteConfig {\n  constructor( // Required by FirebaseServiceFactory interface.\n  app, // JS doesn't support private yet\n  // (https://github.com/tc39/proposal-class-fields#private-fields), so we hint using an\n  // underscore prefix.\n\n  /**\r\n   * @internal\r\n   */\n  _client,\n  /**\r\n   * @internal\r\n   */\n  _storageCache,\n  /**\r\n   * @internal\r\n   */\n  _storage,\n  /**\r\n   * @internal\r\n   */\n  _logger) {\n    this.app = app;\n    this._client = _client;\n    this._storageCache = _storageCache;\n    this._storage = _storage;\n    this._logger = _logger;\n    /**\r\n     * Tracks completion of initialization promise.\r\n     * @internal\r\n     */\n\n    this._isInitializationComplete = false;\n    this.settings = {\n      fetchTimeoutMillis: DEFAULT_FETCH_TIMEOUT_MILLIS,\n      minimumFetchIntervalMillis: DEFAULT_CACHE_MAX_AGE_MILLIS\n    };\n    this.defaultConfig = {};\n  }\n\n  get fetchTimeMillis() {\n    return this._storageCache.getLastSuccessfulFetchTimestampMillis() || -1;\n  }\n\n  get lastFetchStatus() {\n    return this._storageCache.getLastFetchStatus() || 'no-fetch-yet';\n  }\n\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * Converts an error event associated with a {@link IDBRequest} to a {@link FirebaseError}.\r\n */\n\n\nfunction toFirebaseError(event, errorCode) {\n  const originalError = event.target.error || undefined;\n  return ERROR_FACTORY.create(errorCode, {\n    originalErrorMessage: originalError && (originalError === null || originalError === void 0 ? void 0 : originalError.message)\n  });\n}\n/**\r\n * A general-purpose store keyed by app + namespace + {@link\r\n * ProjectNamespaceKeyFieldValue}.\r\n *\r\n * <p>The Remote Config SDK can be used with multiple app installations, and each app can interact\r\n * with multiple namespaces, so this store uses app (ID + name) and namespace as common parent keys\r\n * for a set of key-value pairs. See {@link Storage#createCompositeKey}.\r\n *\r\n * <p>Visible for testing.\r\n */\n\n\nconst APP_NAMESPACE_STORE = 'app_namespace_store';\nconst DB_NAME = 'firebase_remote_config';\nconst DB_VERSION = 1; // Visible for testing.\n\nfunction openDatabase() {\n  return new Promise((resolve, reject) => {\n    try {\n      const request = indexedDB.open(DB_NAME, DB_VERSION);\n\n      request.onerror = event => {\n        reject(toFirebaseError(event, \"storage-open\"\n        /* ErrorCode.STORAGE_OPEN */\n        ));\n      };\n\n      request.onsuccess = event => {\n        resolve(event.target.result);\n      };\n\n      request.onupgradeneeded = event => {\n        const db = event.target.result; // We don't use 'break' in this switch statement, the fall-through\n        // behavior is what we want, because if there are multiple versions between\n        // the old version and the current version, we want ALL the migrations\n        // that correspond to those versions to run, not only the last one.\n        // eslint-disable-next-line default-case\n\n        switch (event.oldVersion) {\n          case 0:\n            db.createObjectStore(APP_NAMESPACE_STORE, {\n              keyPath: 'compositeKey'\n            });\n        }\n      };\n    } catch (error) {\n      reject(ERROR_FACTORY.create(\"storage-open\"\n      /* ErrorCode.STORAGE_OPEN */\n      , {\n        originalErrorMessage: error === null || error === void 0 ? void 0 : error.message\n      }));\n    }\n  });\n}\n/**\r\n * Abstracts data persistence.\r\n */\n\n\nclass Storage {\n  /**\r\n   * @param appId enables storage segmentation by app (ID + name).\r\n   * @param appName enables storage segmentation by app (ID + name).\r\n   * @param namespace enables storage segmentation by namespace.\r\n   */\n  constructor(appId, appName, namespace, openDbPromise = openDatabase()) {\n    this.appId = appId;\n    this.appName = appName;\n    this.namespace = namespace;\n    this.openDbPromise = openDbPromise;\n  }\n\n  getLastFetchStatus() {\n    return this.get('last_fetch_status');\n  }\n\n  setLastFetchStatus(status) {\n    return this.set('last_fetch_status', status);\n  } // This is comparable to a cache entry timestamp. If we need to expire other data, we could\n  // consider adding timestamp to all storage records and an optional max age arg to getters.\n\n\n  getLastSuccessfulFetchTimestampMillis() {\n    return this.get('last_successful_fetch_timestamp_millis');\n  }\n\n  setLastSuccessfulFetchTimestampMillis(timestamp) {\n    return this.set('last_successful_fetch_timestamp_millis', timestamp);\n  }\n\n  getLastSuccessfulFetchResponse() {\n    return this.get('last_successful_fetch_response');\n  }\n\n  setLastSuccessfulFetchResponse(response) {\n    return this.set('last_successful_fetch_response', response);\n  }\n\n  getActiveConfig() {\n    return this.get('active_config');\n  }\n\n  setActiveConfig(config) {\n    return this.set('active_config', config);\n  }\n\n  getActiveConfigEtag() {\n    return this.get('active_config_etag');\n  }\n\n  setActiveConfigEtag(etag) {\n    return this.set('active_config_etag', etag);\n  }\n\n  getThrottleMetadata() {\n    return this.get('throttle_metadata');\n  }\n\n  setThrottleMetadata(metadata) {\n    return this.set('throttle_metadata', metadata);\n  }\n\n  deleteThrottleMetadata() {\n    return this.delete('throttle_metadata');\n  }\n\n  get(key) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      const db = yield _this5.openDbPromise;\n      return new Promise((resolve, reject) => {\n        const transaction = db.transaction([APP_NAMESPACE_STORE], 'readonly');\n        const objectStore = transaction.objectStore(APP_NAMESPACE_STORE);\n\n        const compositeKey = _this5.createCompositeKey(key);\n\n        try {\n          const request = objectStore.get(compositeKey);\n\n          request.onerror = event => {\n            reject(toFirebaseError(event, \"storage-get\"\n            /* ErrorCode.STORAGE_GET */\n            ));\n          };\n\n          request.onsuccess = event => {\n            const result = event.target.result;\n\n            if (result) {\n              resolve(result.value);\n            } else {\n              resolve(undefined);\n            }\n          };\n        } catch (e) {\n          reject(ERROR_FACTORY.create(\"storage-get\"\n          /* ErrorCode.STORAGE_GET */\n          , {\n            originalErrorMessage: e === null || e === void 0 ? void 0 : e.message\n          }));\n        }\n      });\n    })();\n  }\n\n  set(key, value) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      const db = yield _this6.openDbPromise;\n      return new Promise((resolve, reject) => {\n        const transaction = db.transaction([APP_NAMESPACE_STORE], 'readwrite');\n        const objectStore = transaction.objectStore(APP_NAMESPACE_STORE);\n\n        const compositeKey = _this6.createCompositeKey(key);\n\n        try {\n          const request = objectStore.put({\n            compositeKey,\n            value\n          });\n\n          request.onerror = event => {\n            reject(toFirebaseError(event, \"storage-set\"\n            /* ErrorCode.STORAGE_SET */\n            ));\n          };\n\n          request.onsuccess = () => {\n            resolve();\n          };\n        } catch (e) {\n          reject(ERROR_FACTORY.create(\"storage-set\"\n          /* ErrorCode.STORAGE_SET */\n          , {\n            originalErrorMessage: e === null || e === void 0 ? void 0 : e.message\n          }));\n        }\n      });\n    })();\n  }\n\n  delete(key) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      const db = yield _this7.openDbPromise;\n      return new Promise((resolve, reject) => {\n        const transaction = db.transaction([APP_NAMESPACE_STORE], 'readwrite');\n        const objectStore = transaction.objectStore(APP_NAMESPACE_STORE);\n\n        const compositeKey = _this7.createCompositeKey(key);\n\n        try {\n          const request = objectStore.delete(compositeKey);\n\n          request.onerror = event => {\n            reject(toFirebaseError(event, \"storage-delete\"\n            /* ErrorCode.STORAGE_DELETE */\n            ));\n          };\n\n          request.onsuccess = () => {\n            resolve();\n          };\n        } catch (e) {\n          reject(ERROR_FACTORY.create(\"storage-delete\"\n          /* ErrorCode.STORAGE_DELETE */\n          , {\n            originalErrorMessage: e === null || e === void 0 ? void 0 : e.message\n          }));\n        }\n      });\n    })();\n  } // Facilitates composite key functionality (which is unsupported in IE).\n\n\n  createCompositeKey(key) {\n    return [this.appId, this.appName, this.namespace, key].join();\n  }\n\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * A memory cache layer over storage to support the SDK's synchronous read requirements.\r\n */\n\n\nclass StorageCache {\n  constructor(storage) {\n    this.storage = storage;\n  }\n  /**\r\n   * Memory-only getters\r\n   */\n\n\n  getLastFetchStatus() {\n    return this.lastFetchStatus;\n  }\n\n  getLastSuccessfulFetchTimestampMillis() {\n    return this.lastSuccessfulFetchTimestampMillis;\n  }\n\n  getActiveConfig() {\n    return this.activeConfig;\n  }\n  /**\r\n   * Read-ahead getter\r\n   */\n\n\n  loadFromStorage() {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      const lastFetchStatusPromise = _this8.storage.getLastFetchStatus();\n\n      const lastSuccessfulFetchTimestampMillisPromise = _this8.storage.getLastSuccessfulFetchTimestampMillis();\n\n      const activeConfigPromise = _this8.storage.getActiveConfig(); // Note:\n      // 1. we consistently check for undefined to avoid clobbering defined values\n      //   in memory\n      // 2. we defer awaiting to improve readability, as opposed to destructuring\n      //   a Promise.all result, for example\n\n\n      const lastFetchStatus = yield lastFetchStatusPromise;\n\n      if (lastFetchStatus) {\n        _this8.lastFetchStatus = lastFetchStatus;\n      }\n\n      const lastSuccessfulFetchTimestampMillis = yield lastSuccessfulFetchTimestampMillisPromise;\n\n      if (lastSuccessfulFetchTimestampMillis) {\n        _this8.lastSuccessfulFetchTimestampMillis = lastSuccessfulFetchTimestampMillis;\n      }\n\n      const activeConfig = yield activeConfigPromise;\n\n      if (activeConfig) {\n        _this8.activeConfig = activeConfig;\n      }\n    })();\n  }\n  /**\r\n   * Write-through setters\r\n   */\n\n\n  setLastFetchStatus(status) {\n    this.lastFetchStatus = status;\n    return this.storage.setLastFetchStatus(status);\n  }\n\n  setLastSuccessfulFetchTimestampMillis(timestampMillis) {\n    this.lastSuccessfulFetchTimestampMillis = timestampMillis;\n    return this.storage.setLastSuccessfulFetchTimestampMillis(timestampMillis);\n  }\n\n  setActiveConfig(activeConfig) {\n    this.activeConfig = activeConfig;\n    return this.storage.setActiveConfig(activeConfig);\n  }\n\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nfunction registerRemoteConfig() {\n  _registerComponent(new Component(RC_COMPONENT_NAME, remoteConfigFactory, \"PUBLIC\"\n  /* ComponentType.PUBLIC */\n  ).setMultipleInstances(true));\n\n  registerVersion(name, version); // BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation\n\n  registerVersion(name, version, 'esm2017');\n\n  function remoteConfigFactory(container, {\n    instanceIdentifier: namespace\n  }) {\n    /* Dependencies */\n    // getImmediate for FirebaseApp will always succeed\n    const app = container.getProvider('app').getImmediate(); // The following call will always succeed because rc has `import '@firebase/installations'`\n\n    const installations = container.getProvider('installations-internal').getImmediate(); // Guards against the SDK being used in non-browser environments.\n\n    if (typeof window === 'undefined') {\n      throw ERROR_FACTORY.create(\"registration-window\"\n      /* ErrorCode.REGISTRATION_WINDOW */\n      );\n    } // Guards against the SDK being used when indexedDB is not available.\n\n\n    if (!isIndexedDBAvailable()) {\n      throw ERROR_FACTORY.create(\"indexed-db-unavailable\"\n      /* ErrorCode.INDEXED_DB_UNAVAILABLE */\n      );\n    } // Normalizes optional inputs.\n\n\n    const {\n      projectId,\n      apiKey,\n      appId\n    } = app.options;\n\n    if (!projectId) {\n      throw ERROR_FACTORY.create(\"registration-project-id\"\n      /* ErrorCode.REGISTRATION_PROJECT_ID */\n      );\n    }\n\n    if (!apiKey) {\n      throw ERROR_FACTORY.create(\"registration-api-key\"\n      /* ErrorCode.REGISTRATION_API_KEY */\n      );\n    }\n\n    if (!appId) {\n      throw ERROR_FACTORY.create(\"registration-app-id\"\n      /* ErrorCode.REGISTRATION_APP_ID */\n      );\n    }\n\n    namespace = namespace || 'firebase';\n    const storage = new Storage(appId, app.name, namespace);\n    const storageCache = new StorageCache(storage);\n    const logger = new Logger(name); // Sets ERROR as the default log level.\n    // See RemoteConfig#setLogLevel for corresponding normalization to ERROR log level.\n\n    logger.logLevel = LogLevel.ERROR;\n    const restClient = new RestClient(installations, // Uses the JS SDK version, by which the RC package version can be deduced, if necessary.\n    SDK_VERSION, namespace, projectId, apiKey, appId);\n    const retryingClient = new RetryingClient(restClient, storage);\n    const cachingClient = new CachingClient(retryingClient, storage, storageCache, logger);\n    const remoteConfigInstance = new RemoteConfig(app, cachingClient, storageCache, storage, logger); // Starts warming cache.\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n\n    ensureInitialized(remoteConfigInstance);\n    return remoteConfigInstance;\n  }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n// This API is put in a separate file, so we can stub fetchConfig and activate in tests.\n// It's not possible to stub standalone functions from the same module.\n\n/**\r\n *\r\n * Performs fetch and activate operations, as a convenience.\r\n *\r\n * @param remoteConfig - The {@link RemoteConfig} instance.\r\n *\r\n * @returns A `Promise` which resolves to true if the current call activated the fetched configs.\r\n * If the fetched configs were already activated, the `Promise` will resolve to false.\r\n *\r\n * @public\r\n */\n\n\nfunction fetchAndActivate(_x3) {\n  return _fetchAndActivate.apply(this, arguments);\n}\n/**\r\n * This method provides two different checks:\r\n *\r\n * 1. Check if IndexedDB exists in the browser environment.\r\n * 2. Check if the current browser context allows IndexedDB `open()` calls.\r\n *\r\n * @returns A `Promise` which resolves to true if a {@link RemoteConfig} instance\r\n * can be initialized in this environment, or false if it cannot.\r\n * @public\r\n */\n\n\nfunction _fetchAndActivate() {\n  _fetchAndActivate = _asyncToGenerator(function* (remoteConfig) {\n    remoteConfig = getModularInstance(remoteConfig);\n    yield fetchConfig(remoteConfig);\n    return activate(remoteConfig);\n  });\n  return _fetchAndActivate.apply(this, arguments);\n}\n\nfunction isSupported() {\n  return _isSupported.apply(this, arguments);\n}\n/**\r\n * Firebase Remote Config\r\n *\r\n * @packageDocumentation\r\n */\n\n/** register component and version */\n\n\nfunction _isSupported() {\n  _isSupported = _asyncToGenerator(function* () {\n    if (!isIndexedDBAvailable()) {\n      return false;\n    }\n\n    try {\n      const isDBOpenable = yield validateIndexedDBOpenable();\n      return isDBOpenable;\n    } catch (error) {\n      return false;\n    }\n  });\n  return _isSupported.apply(this, arguments);\n}\n\nregisterRemoteConfig();\nexport { activate, ensureInitialized, fetchAndActivate, fetchConfig, getAll, getBoolean, getNumber, getRemoteConfig, getString, getValue, isSupported, setLogLevel }; //# sourceMappingURL=index.esm2017.js.map","map":null,"metadata":{},"sourceType":"module"}