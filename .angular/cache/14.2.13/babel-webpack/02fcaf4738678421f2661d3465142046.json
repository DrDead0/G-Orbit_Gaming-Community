{"ast":null,"code":"import _asyncToGenerator from \"D:/Gamer`s Orbit/clips/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { _getProvider, getApp, _registerComponent, registerVersion } from '@firebase/app';\nimport { Logger } from '@firebase/logger';\nimport { ErrorFactory, calculateBackoffMillis, FirebaseError, isIndexedDBAvailable, validateIndexedDBOpenable, isBrowserExtension, areCookiesEnabled, getModularInstance, deepEqual } from '@firebase/util';\nimport { Component } from '@firebase/component';\nimport '@firebase/installations';\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * Type constant for Firebase Analytics.\r\n */\n\nconst ANALYTICS_TYPE = 'analytics'; // Key to attach FID to in gtag params.\n\nconst GA_FID_KEY = 'firebase_id';\nconst ORIGIN_KEY = 'origin';\nconst FETCH_TIMEOUT_MILLIS = 60 * 1000;\nconst DYNAMIC_CONFIG_URL = 'https://firebase.googleapis.com/v1alpha/projects/-/apps/{app-id}/webConfig';\nconst GTAG_URL = 'https://www.googletagmanager.com/gtag/js';\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nconst logger = new Logger('@firebase/analytics');\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nconst ERRORS = {\n  [\"already-exists\"\n  /* AnalyticsError.ALREADY_EXISTS */\n  ]: 'A Firebase Analytics instance with the appId {$id} ' + ' already exists. ' + 'Only one Firebase Analytics instance can be created for each appId.',\n  [\"already-initialized\"\n  /* AnalyticsError.ALREADY_INITIALIZED */\n  ]: 'initializeAnalytics() cannot be called again with different options than those ' + 'it was initially called with. It can be called again with the same options to ' + 'return the existing instance, or getAnalytics() can be used ' + 'to get a reference to the already-intialized instance.',\n  [\"already-initialized-settings\"\n  /* AnalyticsError.ALREADY_INITIALIZED_SETTINGS */\n  ]: 'Firebase Analytics has already been initialized.' + 'settings() must be called before initializing any Analytics instance' + 'or it will have no effect.',\n  [\"interop-component-reg-failed\"\n  /* AnalyticsError.INTEROP_COMPONENT_REG_FAILED */\n  ]: 'Firebase Analytics Interop Component failed to instantiate: {$reason}',\n  [\"invalid-analytics-context\"\n  /* AnalyticsError.INVALID_ANALYTICS_CONTEXT */\n  ]: 'Firebase Analytics is not supported in this environment. ' + 'Wrap initialization of analytics in analytics.isSupported() ' + 'to prevent initialization in unsupported environments. Details: {$errorInfo}',\n  [\"indexeddb-unavailable\"\n  /* AnalyticsError.INDEXEDDB_UNAVAILABLE */\n  ]: 'IndexedDB unavailable or restricted in this environment. ' + 'Wrap initialization of analytics in analytics.isSupported() ' + 'to prevent initialization in unsupported environments. Details: {$errorInfo}',\n  [\"fetch-throttle\"\n  /* AnalyticsError.FETCH_THROTTLE */\n  ]: 'The config fetch request timed out while in an exponential backoff state.' + ' Unix timestamp in milliseconds when fetch request throttling ends: {$throttleEndTimeMillis}.',\n  [\"config-fetch-failed\"\n  /* AnalyticsError.CONFIG_FETCH_FAILED */\n  ]: 'Dynamic config fetch failed: [{$httpStatus}] {$responseMessage}',\n  [\"no-api-key\"\n  /* AnalyticsError.NO_API_KEY */\n  ]: 'The \"apiKey\" field is empty in the local Firebase config. Firebase Analytics requires this field to' + 'contain a valid API key.',\n  [\"no-app-id\"\n  /* AnalyticsError.NO_APP_ID */\n  ]: 'The \"appId\" field is empty in the local Firebase config. Firebase Analytics requires this field to' + 'contain a valid app ID.',\n  [\"no-client-id\"\n  /* AnalyticsError.NO_CLIENT_ID */\n  ]: 'The \"client_id\" field is empty.',\n  [\"invalid-gtag-resource\"\n  /* AnalyticsError.INVALID_GTAG_RESOURCE */\n  ]: 'Trusted Types detected an invalid gtag resource: {$gtagURL}.'\n};\nconst ERROR_FACTORY = new ErrorFactory('analytics', 'Analytics', ERRORS);\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * Verifies and creates a TrustedScriptURL.\r\n */\n\nfunction createGtagTrustedTypesScriptURL(url) {\n  if (!url.startsWith(GTAG_URL)) {\n    const err = ERROR_FACTORY.create(\"invalid-gtag-resource\"\n    /* AnalyticsError.INVALID_GTAG_RESOURCE */\n    , {\n      gtagURL: url\n    });\n    logger.warn(err.message);\n    return '';\n  }\n\n  return url;\n}\n/**\r\n * Makeshift polyfill for Promise.allSettled(). Resolves when all promises\r\n * have either resolved or rejected.\r\n *\r\n * @param promises Array of promises to wait for.\r\n */\n\n\nfunction promiseAllSettled(promises) {\n  return Promise.all(promises.map(promise => promise.catch(e => e)));\n}\n/**\r\n * Creates a TrustedTypePolicy object that implements the rules passed as policyOptions.\r\n *\r\n * @param policyName A string containing the name of the policy\r\n * @param policyOptions Object containing implementations of instance methods for TrustedTypesPolicy, see {@link https://developer.mozilla.org/en-US/docs/Web/API/TrustedTypePolicy#instance_methods\r\n * | the TrustedTypePolicy reference documentation}.\r\n */\n\n\nfunction createTrustedTypesPolicy(policyName, policyOptions) {\n  // Create a TrustedTypes policy that we can use for updating src\n  // properties\n  let trustedTypesPolicy;\n\n  if (window.trustedTypes) {\n    trustedTypesPolicy = window.trustedTypes.createPolicy(policyName, policyOptions);\n  }\n\n  return trustedTypesPolicy;\n}\n/**\r\n * Inserts gtag script tag into the page to asynchronously download gtag.\r\n * @param dataLayerName Name of datalayer (most often the default, \"_dataLayer\").\r\n */\n\n\nfunction insertScriptTag(dataLayerName, measurementId) {\n  const trustedTypesPolicy = createTrustedTypesPolicy('firebase-js-sdk-policy', {\n    createScriptURL: createGtagTrustedTypesScriptURL\n  });\n  const script = document.createElement('script'); // We are not providing an analyticsId in the URL because it would trigger a `page_view`\n  // without fid. We will initialize ga-id using gtag (config) command together with fid.\n\n  const gtagScriptURL = `${GTAG_URL}?l=${dataLayerName}&id=${measurementId}`;\n  script.src = trustedTypesPolicy ? trustedTypesPolicy === null || trustedTypesPolicy === void 0 ? void 0 : trustedTypesPolicy.createScriptURL(gtagScriptURL) : gtagScriptURL;\n  script.async = true;\n  document.head.appendChild(script);\n}\n/**\r\n * Get reference to, or create, global datalayer.\r\n * @param dataLayerName Name of datalayer (most often the default, \"_dataLayer\").\r\n */\n\n\nfunction getOrCreateDataLayer(dataLayerName) {\n  // Check for existing dataLayer and create if needed.\n  let dataLayer = [];\n\n  if (Array.isArray(window[dataLayerName])) {\n    dataLayer = window[dataLayerName];\n  } else {\n    window[dataLayerName] = dataLayer;\n  }\n\n  return dataLayer;\n}\n/**\r\n * Wrapped gtag logic when gtag is called with 'config' command.\r\n *\r\n * @param gtagCore Basic gtag function that just appends to dataLayer.\r\n * @param initializationPromisesMap Map of appIds to their initialization promises.\r\n * @param dynamicConfigPromisesList Array of dynamic config fetch promises.\r\n * @param measurementIdToAppId Map of GA measurementIDs to corresponding Firebase appId.\r\n * @param measurementId GA Measurement ID to set config for.\r\n * @param gtagParams Gtag config params to set.\r\n */\n\n\nfunction gtagOnConfig(_x, _x2, _x3, _x4, _x5, _x6) {\n  return _gtagOnConfig.apply(this, arguments);\n}\n/**\r\n * Wrapped gtag logic when gtag is called with 'event' command.\r\n *\r\n * @param gtagCore Basic gtag function that just appends to dataLayer.\r\n * @param initializationPromisesMap Map of appIds to their initialization promises.\r\n * @param dynamicConfigPromisesList Array of dynamic config fetch promises.\r\n * @param measurementId GA Measurement ID to log event to.\r\n * @param gtagParams Params to log with this event.\r\n */\n\n\nfunction _gtagOnConfig() {\n  _gtagOnConfig = _asyncToGenerator(function* (gtagCore, initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId, measurementId, gtagParams) {\n    // If config is already fetched, we know the appId and can use it to look up what FID promise we\n    /// are waiting for, and wait only on that one.\n    const correspondingAppId = measurementIdToAppId[measurementId];\n\n    try {\n      if (correspondingAppId) {\n        yield initializationPromisesMap[correspondingAppId];\n      } else {\n        // If config is not fetched yet, wait for all configs (we don't know which one we need) and\n        // find the appId (if any) corresponding to this measurementId. If there is one, wait on\n        // that appId's initialization promise. If there is none, promise resolves and gtag\n        // call goes through.\n        const dynamicConfigResults = yield promiseAllSettled(dynamicConfigPromisesList);\n        const foundConfig = dynamicConfigResults.find(config => config.measurementId === measurementId);\n\n        if (foundConfig) {\n          yield initializationPromisesMap[foundConfig.appId];\n        }\n      }\n    } catch (e) {\n      logger.error(e);\n    }\n\n    gtagCore(\"config\"\n    /* GtagCommand.CONFIG */\n    , measurementId, gtagParams);\n  });\n  return _gtagOnConfig.apply(this, arguments);\n}\n\nfunction gtagOnEvent(_x7, _x8, _x9, _x10, _x11) {\n  return _gtagOnEvent.apply(this, arguments);\n}\n/**\r\n * Wraps a standard gtag function with extra code to wait for completion of\r\n * relevant initialization promises before sending requests.\r\n *\r\n * @param gtagCore Basic gtag function that just appends to dataLayer.\r\n * @param initializationPromisesMap Map of appIds to their initialization promises.\r\n * @param dynamicConfigPromisesList Array of dynamic config fetch promises.\r\n * @param measurementIdToAppId Map of GA measurementIDs to corresponding Firebase appId.\r\n */\n\n\nfunction _gtagOnEvent() {\n  _gtagOnEvent = _asyncToGenerator(function* (gtagCore, initializationPromisesMap, dynamicConfigPromisesList, measurementId, gtagParams) {\n    try {\n      let initializationPromisesToWaitFor = []; // If there's a 'send_to' param, check if any ID specified matches\n      // an initializeIds() promise we are waiting for.\n\n      if (gtagParams && gtagParams['send_to']) {\n        let gaSendToList = gtagParams['send_to']; // Make it an array if is isn't, so it can be dealt with the same way.\n\n        if (!Array.isArray(gaSendToList)) {\n          gaSendToList = [gaSendToList];\n        } // Checking 'send_to' fields requires having all measurement ID results back from\n        // the dynamic config fetch.\n\n\n        const dynamicConfigResults = yield promiseAllSettled(dynamicConfigPromisesList);\n\n        for (const sendToId of gaSendToList) {\n          // Any fetched dynamic measurement ID that matches this 'send_to' ID\n          const foundConfig = dynamicConfigResults.find(config => config.measurementId === sendToId);\n          const initializationPromise = foundConfig && initializationPromisesMap[foundConfig.appId];\n\n          if (initializationPromise) {\n            initializationPromisesToWaitFor.push(initializationPromise);\n          } else {\n            // Found an item in 'send_to' that is not associated\n            // directly with an FID, possibly a group.  Empty this array,\n            // exit the loop early, and let it get populated below.\n            initializationPromisesToWaitFor = [];\n            break;\n          }\n        }\n      } // This will be unpopulated if there was no 'send_to' field , or\n      // if not all entries in the 'send_to' field could be mapped to\n      // a FID. In these cases, wait on all pending initialization promises.\n\n\n      if (initializationPromisesToWaitFor.length === 0) {\n        initializationPromisesToWaitFor = Object.values(initializationPromisesMap);\n      } // Run core gtag function with args after all relevant initialization\n      // promises have been resolved.\n\n\n      yield Promise.all(initializationPromisesToWaitFor); // Workaround for http://b/141370449 - third argument cannot be undefined.\n\n      gtagCore(\"event\"\n      /* GtagCommand.EVENT */\n      , measurementId, gtagParams || {});\n    } catch (e) {\n      logger.error(e);\n    }\n  });\n  return _gtagOnEvent.apply(this, arguments);\n}\n\nfunction wrapGtag(gtagCore,\n/**\r\n * Allows wrapped gtag calls to wait on whichever intialization promises are required,\r\n * depending on the contents of the gtag params' `send_to` field, if any.\r\n */\ninitializationPromisesMap,\n/**\r\n * Wrapped gtag calls sometimes require all dynamic config fetches to have returned\r\n * before determining what initialization promises (which include FIDs) to wait for.\r\n */\ndynamicConfigPromisesList,\n/**\r\n * Wrapped gtag config calls can narrow down which initialization promise (with FID)\r\n * to wait for if the measurementId is already fetched, by getting the corresponding appId,\r\n * which is the key for the initialization promises map.\r\n */\nmeasurementIdToAppId) {\n  /**\r\n   * Wrapper around gtag that ensures FID is sent with gtag calls.\r\n   * @param command Gtag command type.\r\n   * @param idOrNameOrParams Measurement ID if command is EVENT/CONFIG, params if command is SET.\r\n   * @param gtagParams Params if event is EVENT/CONFIG.\r\n   */\n  function gtagWrapper(_x12) {\n    return _gtagWrapper.apply(this, arguments);\n  }\n\n  function _gtagWrapper() {\n    _gtagWrapper = _asyncToGenerator(function* (command, ...args) {\n      try {\n        // If event, check that relevant initialization promises have completed.\n        if (command === \"event\"\n        /* GtagCommand.EVENT */\n        ) {\n          const [measurementId, gtagParams] = args; // If EVENT, second arg must be measurementId.\n\n          yield gtagOnEvent(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, measurementId, gtagParams);\n        } else if (command === \"config\"\n        /* GtagCommand.CONFIG */\n        ) {\n          const [measurementId, gtagParams] = args; // If CONFIG, second arg must be measurementId.\n\n          yield gtagOnConfig(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId, measurementId, gtagParams);\n        } else if (command === \"consent\"\n        /* GtagCommand.CONSENT */\n        ) {\n          const [gtagParams] = args;\n          gtagCore(\"consent\"\n          /* GtagCommand.CONSENT */\n          , 'update', gtagParams);\n        } else if (command === \"get\"\n        /* GtagCommand.GET */\n        ) {\n          const [measurementId, fieldName, callback] = args;\n          gtagCore(\"get\"\n          /* GtagCommand.GET */\n          , measurementId, fieldName, callback);\n        } else if (command === \"set\"\n        /* GtagCommand.SET */\n        ) {\n          const [customParams] = args; // If SET, second arg must be params.\n\n          gtagCore(\"set\"\n          /* GtagCommand.SET */\n          , customParams);\n        } else {\n          gtagCore(command, ...args);\n        }\n      } catch (e) {\n        logger.error(e);\n      }\n    });\n    return _gtagWrapper.apply(this, arguments);\n  }\n\n  return gtagWrapper;\n}\n/**\r\n * Creates global gtag function or wraps existing one if found.\r\n * This wrapped function attaches Firebase instance ID (FID) to gtag 'config' and\r\n * 'event' calls that belong to the GAID associated with this Firebase instance.\r\n *\r\n * @param initializationPromisesMap Map of appIds to their initialization promises.\r\n * @param dynamicConfigPromisesList Array of dynamic config fetch promises.\r\n * @param measurementIdToAppId Map of GA measurementIDs to corresponding Firebase appId.\r\n * @param dataLayerName Name of global GA datalayer array.\r\n * @param gtagFunctionName Name of global gtag function (\"gtag\" if not user-specified).\r\n */\n\n\nfunction wrapOrCreateGtag(initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId, dataLayerName, gtagFunctionName) {\n  // Create a basic core gtag function\n  let gtagCore = function (..._args) {\n    // Must push IArguments object, not an array.\n    window[dataLayerName].push(arguments);\n  }; // Replace it with existing one if found\n\n\n  if (window[gtagFunctionName] && typeof window[gtagFunctionName] === 'function') {\n    // @ts-ignore\n    gtagCore = window[gtagFunctionName];\n  }\n\n  window[gtagFunctionName] = wrapGtag(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId);\n  return {\n    gtagCore,\n    wrappedGtag: window[gtagFunctionName]\n  };\n}\n/**\r\n * Returns the script tag in the DOM matching both the gtag url pattern\r\n * and the provided data layer name.\r\n */\n\n\nfunction findGtagScriptOnPage(dataLayerName) {\n  const scriptTags = window.document.getElementsByTagName('script');\n\n  for (const tag of Object.values(scriptTags)) {\n    if (tag.src && tag.src.includes(GTAG_URL) && tag.src.includes(dataLayerName)) {\n      return tag;\n    }\n  }\n\n  return null;\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * Backoff factor for 503 errors, which we want to be conservative about\r\n * to avoid overloading servers. Each retry interval will be\r\n * BASE_INTERVAL_MILLIS * LONG_RETRY_FACTOR ^ retryCount, so the second one\r\n * will be ~30 seconds (with fuzzing).\r\n */\n\n\nconst LONG_RETRY_FACTOR = 30;\n/**\r\n * Base wait interval to multiplied by backoffFactor^backoffCount.\r\n */\n\nconst BASE_INTERVAL_MILLIS = 1000;\n/**\r\n * Stubbable retry data storage class.\r\n */\n\nclass RetryData {\n  constructor(throttleMetadata = {}, intervalMillis = BASE_INTERVAL_MILLIS) {\n    this.throttleMetadata = throttleMetadata;\n    this.intervalMillis = intervalMillis;\n  }\n\n  getThrottleMetadata(appId) {\n    return this.throttleMetadata[appId];\n  }\n\n  setThrottleMetadata(appId, metadata) {\n    this.throttleMetadata[appId] = metadata;\n  }\n\n  deleteThrottleMetadata(appId) {\n    delete this.throttleMetadata[appId];\n  }\n\n}\n\nconst defaultRetryData = new RetryData();\n/**\r\n * Set GET request headers.\r\n * @param apiKey App API key.\r\n */\n\nfunction getHeaders(apiKey) {\n  return new Headers({\n    Accept: 'application/json',\n    'x-goog-api-key': apiKey\n  });\n}\n/**\r\n * Fetches dynamic config from backend.\r\n * @param app Firebase app to fetch config for.\r\n */\n\n\nfunction fetchDynamicConfig(_x13) {\n  return _fetchDynamicConfig.apply(this, arguments);\n}\n/**\r\n * Fetches dynamic config from backend, retrying if failed.\r\n * @param app Firebase app to fetch config for.\r\n */\n\n\nfunction _fetchDynamicConfig() {\n  _fetchDynamicConfig = _asyncToGenerator(function* (appFields) {\n    var _a;\n\n    const {\n      appId,\n      apiKey\n    } = appFields;\n    const request = {\n      method: 'GET',\n      headers: getHeaders(apiKey)\n    };\n    const appUrl = DYNAMIC_CONFIG_URL.replace('{app-id}', appId);\n    const response = yield fetch(appUrl, request);\n\n    if (response.status !== 200 && response.status !== 304) {\n      let errorMessage = '';\n\n      try {\n        // Try to get any error message text from server response.\n        const jsonResponse = yield response.json();\n\n        if ((_a = jsonResponse.error) === null || _a === void 0 ? void 0 : _a.message) {\n          errorMessage = jsonResponse.error.message;\n        }\n      } catch (_ignored) {}\n\n      throw ERROR_FACTORY.create(\"config-fetch-failed\"\n      /* AnalyticsError.CONFIG_FETCH_FAILED */\n      , {\n        httpStatus: response.status,\n        responseMessage: errorMessage\n      });\n    }\n\n    return response.json();\n  });\n  return _fetchDynamicConfig.apply(this, arguments);\n}\n\nfunction fetchDynamicConfigWithRetry(_x14) {\n  return _fetchDynamicConfigWithRetry.apply(this, arguments);\n}\n/**\r\n * Runs one retry attempt.\r\n * @param appFields Necessary app config fields.\r\n * @param throttleMetadata Ongoing metadata to determine throttling times.\r\n * @param signal Abort signal.\r\n */\n\n\nfunction _fetchDynamicConfigWithRetry() {\n  _fetchDynamicConfigWithRetry = _asyncToGenerator(function* (app, // retryData and timeoutMillis are parameterized to allow passing a different value for testing.\n  retryData = defaultRetryData, timeoutMillis) {\n    const {\n      appId,\n      apiKey,\n      measurementId\n    } = app.options;\n\n    if (!appId) {\n      throw ERROR_FACTORY.create(\"no-app-id\"\n      /* AnalyticsError.NO_APP_ID */\n      );\n    }\n\n    if (!apiKey) {\n      if (measurementId) {\n        return {\n          measurementId,\n          appId\n        };\n      }\n\n      throw ERROR_FACTORY.create(\"no-api-key\"\n      /* AnalyticsError.NO_API_KEY */\n      );\n    }\n\n    const throttleMetadata = retryData.getThrottleMetadata(appId) || {\n      backoffCount: 0,\n      throttleEndTimeMillis: Date.now()\n    };\n    const signal = new AnalyticsAbortSignal();\n    setTimeout( /*#__PURE__*/_asyncToGenerator(function* () {\n      // Note a very low delay, eg < 10ms, can elapse before listeners are initialized.\n      signal.abort();\n    }), timeoutMillis !== undefined ? timeoutMillis : FETCH_TIMEOUT_MILLIS);\n    return attemptFetchDynamicConfigWithRetry({\n      appId,\n      apiKey,\n      measurementId\n    }, throttleMetadata, signal, retryData);\n  });\n  return _fetchDynamicConfigWithRetry.apply(this, arguments);\n}\n\nfunction attemptFetchDynamicConfigWithRetry(_x15, _x16, _x17) {\n  return _attemptFetchDynamicConfigWithRetry.apply(this, arguments);\n}\n/**\r\n * Supports waiting on a backoff by:\r\n *\r\n * <ul>\r\n *   <li>Promisifying setTimeout, so we can set a timeout in our Promise chain</li>\r\n *   <li>Listening on a signal bus for abort events, just like the Fetch API</li>\r\n *   <li>Failing in the same way the Fetch API fails, so timing out a live request and a throttled\r\n *       request appear the same.</li>\r\n * </ul>\r\n *\r\n * <p>Visible for testing.\r\n */\n\n\nfunction _attemptFetchDynamicConfigWithRetry() {\n  _attemptFetchDynamicConfigWithRetry = _asyncToGenerator(function* (appFields, {\n    throttleEndTimeMillis,\n    backoffCount\n  }, signal, retryData = defaultRetryData // for testing\n  ) {\n    var _a;\n\n    const {\n      appId,\n      measurementId\n    } = appFields; // Starts with a (potentially zero) timeout to support resumption from stored state.\n    // Ensures the throttle end time is honored if the last attempt timed out.\n    // Note the SDK will never make a request if the fetch timeout expires at this point.\n\n    try {\n      yield setAbortableTimeout(signal, throttleEndTimeMillis);\n    } catch (e) {\n      if (measurementId) {\n        logger.warn(`Timed out fetching this Firebase app's measurement ID from the server.` + ` Falling back to the measurement ID ${measurementId}` + ` provided in the \"measurementId\" field in the local Firebase config. [${e === null || e === void 0 ? void 0 : e.message}]`);\n        return {\n          appId,\n          measurementId\n        };\n      }\n\n      throw e;\n    }\n\n    try {\n      const response = yield fetchDynamicConfig(appFields); // Note the SDK only clears throttle state if response is success or non-retriable.\n\n      retryData.deleteThrottleMetadata(appId);\n      return response;\n    } catch (e) {\n      const error = e;\n\n      if (!isRetriableError(error)) {\n        retryData.deleteThrottleMetadata(appId);\n\n        if (measurementId) {\n          logger.warn(`Failed to fetch this Firebase app's measurement ID from the server.` + ` Falling back to the measurement ID ${measurementId}` + ` provided in the \"measurementId\" field in the local Firebase config. [${error === null || error === void 0 ? void 0 : error.message}]`);\n          return {\n            appId,\n            measurementId\n          };\n        } else {\n          throw e;\n        }\n      }\n\n      const backoffMillis = Number((_a = error === null || error === void 0 ? void 0 : error.customData) === null || _a === void 0 ? void 0 : _a.httpStatus) === 503 ? calculateBackoffMillis(backoffCount, retryData.intervalMillis, LONG_RETRY_FACTOR) : calculateBackoffMillis(backoffCount, retryData.intervalMillis); // Increments backoff state.\n\n      const throttleMetadata = {\n        throttleEndTimeMillis: Date.now() + backoffMillis,\n        backoffCount: backoffCount + 1\n      }; // Persists state.\n\n      retryData.setThrottleMetadata(appId, throttleMetadata);\n      logger.debug(`Calling attemptFetch again in ${backoffMillis} millis`);\n      return attemptFetchDynamicConfigWithRetry(appFields, throttleMetadata, signal, retryData);\n    }\n  });\n  return _attemptFetchDynamicConfigWithRetry.apply(this, arguments);\n}\n\nfunction setAbortableTimeout(signal, throttleEndTimeMillis) {\n  return new Promise((resolve, reject) => {\n    // Derives backoff from given end time, normalizing negative numbers to zero.\n    const backoffMillis = Math.max(throttleEndTimeMillis - Date.now(), 0);\n    const timeout = setTimeout(resolve, backoffMillis); // Adds listener, rather than sets onabort, because signal is a shared object.\n\n    signal.addEventListener(() => {\n      clearTimeout(timeout); // If the request completes before this timeout, the rejection has no effect.\n\n      reject(ERROR_FACTORY.create(\"fetch-throttle\"\n      /* AnalyticsError.FETCH_THROTTLE */\n      , {\n        throttleEndTimeMillis\n      }));\n    });\n  });\n}\n/**\r\n * Returns true if the {@link Error} indicates a fetch request may succeed later.\r\n */\n\n\nfunction isRetriableError(e) {\n  if (!(e instanceof FirebaseError) || !e.customData) {\n    return false;\n  } // Uses string index defined by ErrorData, which FirebaseError implements.\n\n\n  const httpStatus = Number(e.customData['httpStatus']);\n  return httpStatus === 429 || httpStatus === 500 || httpStatus === 503 || httpStatus === 504;\n}\n/**\r\n * Shims a minimal AbortSignal (copied from Remote Config).\r\n *\r\n * <p>AbortController's AbortSignal conveniently decouples fetch timeout logic from other aspects\r\n * of networking, such as retries. Firebase doesn't use AbortController enough to justify a\r\n * polyfill recommendation, like we do with the Fetch API, but this minimal shim can easily be\r\n * swapped out if/when we do.\r\n */\n\n\nclass AnalyticsAbortSignal {\n  constructor() {\n    this.listeners = [];\n  }\n\n  addEventListener(listener) {\n    this.listeners.push(listener);\n  }\n\n  abort() {\n    this.listeners.forEach(listener => listener());\n  }\n\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * Event parameters to set on 'gtag' during initialization.\r\n */\n\n\nlet defaultEventParametersForInit;\n/**\r\n * Logs an analytics event through the Firebase SDK.\r\n *\r\n * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event\r\n * @param eventName Google Analytics event name, choose from standard list or use a custom string.\r\n * @param eventParams Analytics event parameters.\r\n */\n\nfunction logEvent$1(_x18, _x19, _x20, _x21, _x22) {\n  return _logEvent$.apply(this, arguments);\n}\n/**\r\n * Set screen_name parameter for this Google Analytics ID.\r\n *\r\n * @deprecated Use {@link logEvent} with `eventName` as 'screen_view' and add relevant `eventParams`.\r\n * See {@link https://firebase.google.com/docs/analytics/screenviews | Track Screenviews}.\r\n *\r\n * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event\r\n * @param screenName Screen name string to set.\r\n */\n\n\nfunction _logEvent$() {\n  _logEvent$ = _asyncToGenerator(function* (gtagFunction, initializationPromise, eventName, eventParams, options) {\n    if (options && options.global) {\n      gtagFunction(\"event\"\n      /* GtagCommand.EVENT */\n      , eventName, eventParams);\n      return;\n    } else {\n      const measurementId = yield initializationPromise;\n      const params = Object.assign(Object.assign({}, eventParams), {\n        'send_to': measurementId\n      });\n      gtagFunction(\"event\"\n      /* GtagCommand.EVENT */\n      , eventName, params);\n    }\n  });\n  return _logEvent$.apply(this, arguments);\n}\n\nfunction setCurrentScreen$1(_x23, _x24, _x25, _x26) {\n  return _setCurrentScreen$.apply(this, arguments);\n}\n/**\r\n * Set user_id parameter for this Google Analytics ID.\r\n *\r\n * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event\r\n * @param id User ID string to set\r\n */\n\n\nfunction _setCurrentScreen$() {\n  _setCurrentScreen$ = _asyncToGenerator(function* (gtagFunction, initializationPromise, screenName, options) {\n    if (options && options.global) {\n      gtagFunction(\"set\"\n      /* GtagCommand.SET */\n      , {\n        'screen_name': screenName\n      });\n      return Promise.resolve();\n    } else {\n      const measurementId = yield initializationPromise;\n      gtagFunction(\"config\"\n      /* GtagCommand.CONFIG */\n      , measurementId, {\n        update: true,\n        'screen_name': screenName\n      });\n    }\n  });\n  return _setCurrentScreen$.apply(this, arguments);\n}\n\nfunction setUserId$1(_x27, _x28, _x29, _x30) {\n  return _setUserId$.apply(this, arguments);\n}\n/**\r\n * Set all other user properties other than user_id and screen_name.\r\n *\r\n * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event\r\n * @param properties Map of user properties to set\r\n */\n\n\nfunction _setUserId$() {\n  _setUserId$ = _asyncToGenerator(function* (gtagFunction, initializationPromise, id, options) {\n    if (options && options.global) {\n      gtagFunction(\"set\"\n      /* GtagCommand.SET */\n      , {\n        'user_id': id\n      });\n      return Promise.resolve();\n    } else {\n      const measurementId = yield initializationPromise;\n      gtagFunction(\"config\"\n      /* GtagCommand.CONFIG */\n      , measurementId, {\n        update: true,\n        'user_id': id\n      });\n    }\n  });\n  return _setUserId$.apply(this, arguments);\n}\n\nfunction setUserProperties$1(_x31, _x32, _x33, _x34) {\n  return _setUserProperties$.apply(this, arguments);\n}\n/**\r\n * Retrieves a unique Google Analytics identifier for the web client.\r\n * See {@link https://developers.google.com/analytics/devguides/collection/ga4/reference/config#client_id | client_id}.\r\n *\r\n * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event\r\n */\n\n\nfunction _setUserProperties$() {\n  _setUserProperties$ = _asyncToGenerator(function* (gtagFunction, initializationPromise, properties, options) {\n    if (options && options.global) {\n      const flatProperties = {};\n\n      for (const key of Object.keys(properties)) {\n        // use dot notation for merge behavior in gtag.js\n        flatProperties[`user_properties.${key}`] = properties[key];\n      }\n\n      gtagFunction(\"set\"\n      /* GtagCommand.SET */\n      , flatProperties);\n      return Promise.resolve();\n    } else {\n      const measurementId = yield initializationPromise;\n      gtagFunction(\"config\"\n      /* GtagCommand.CONFIG */\n      , measurementId, {\n        update: true,\n        'user_properties': properties\n      });\n    }\n  });\n  return _setUserProperties$.apply(this, arguments);\n}\n\nfunction internalGetGoogleAnalyticsClientId(_x35, _x36) {\n  return _internalGetGoogleAnalyticsClientId.apply(this, arguments);\n}\n/**\r\n * Set whether collection is enabled for this ID.\r\n *\r\n * @param enabled If true, collection is enabled for this ID.\r\n */\n\n\nfunction _internalGetGoogleAnalyticsClientId() {\n  _internalGetGoogleAnalyticsClientId = _asyncToGenerator(function* (gtagFunction, initializationPromise) {\n    const measurementId = yield initializationPromise;\n    return new Promise((resolve, reject) => {\n      gtagFunction(\"get\"\n      /* GtagCommand.GET */\n      , measurementId, 'client_id', clientId => {\n        if (!clientId) {\n          reject(ERROR_FACTORY.create(\"no-client-id\"\n          /* AnalyticsError.NO_CLIENT_ID */\n          ));\n        }\n\n        resolve(clientId);\n      });\n    });\n  });\n  return _internalGetGoogleAnalyticsClientId.apply(this, arguments);\n}\n\nfunction setAnalyticsCollectionEnabled$1(_x37, _x38) {\n  return _setAnalyticsCollectionEnabled$.apply(this, arguments);\n}\n/**\r\n * Consent parameters to default to during 'gtag' initialization.\r\n */\n\n\nfunction _setAnalyticsCollectionEnabled$() {\n  _setAnalyticsCollectionEnabled$ = _asyncToGenerator(function* (initializationPromise, enabled) {\n    const measurementId = yield initializationPromise;\n    window[`ga-disable-${measurementId}`] = !enabled;\n  });\n  return _setAnalyticsCollectionEnabled$.apply(this, arguments);\n}\n\nlet defaultConsentSettingsForInit;\n/**\r\n * Sets the variable {@link defaultConsentSettingsForInit} for use in the initialization of\r\n * analytics.\r\n *\r\n * @param consentSettings Maps the applicable end user consent state for gtag.js.\r\n */\n\nfunction _setConsentDefaultForInit(consentSettings) {\n  defaultConsentSettingsForInit = consentSettings;\n}\n/**\r\n * Sets the variable `defaultEventParametersForInit` for use in the initialization of\r\n * analytics.\r\n *\r\n * @param customParams Any custom params the user may pass to gtag.js.\r\n */\n\n\nfunction _setDefaultEventParametersForInit(customParams) {\n  defaultEventParametersForInit = customParams;\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nfunction validateIndexedDB() {\n  return _validateIndexedDB.apply(this, arguments);\n}\n/**\r\n * Initialize the analytics instance in gtag.js by calling config command with fid.\r\n *\r\n * NOTE: We combine analytics initialization and setting fid together because we want fid to be\r\n * part of the `page_view` event that's sent during the initialization\r\n * @param app Firebase app\r\n * @param gtagCore The gtag function that's not wrapped.\r\n * @param dynamicConfigPromisesList Array of all dynamic config promises.\r\n * @param measurementIdToAppId Maps measurementID to appID.\r\n * @param installations _FirebaseInstallationsInternal instance.\r\n *\r\n * @returns Measurement ID.\r\n */\n\n\nfunction _validateIndexedDB() {\n  _validateIndexedDB = _asyncToGenerator(function* () {\n    if (!isIndexedDBAvailable()) {\n      logger.warn(ERROR_FACTORY.create(\"indexeddb-unavailable\"\n      /* AnalyticsError.INDEXEDDB_UNAVAILABLE */\n      , {\n        errorInfo: 'IndexedDB is not available in this environment.'\n      }).message);\n      return false;\n    } else {\n      try {\n        yield validateIndexedDBOpenable();\n      } catch (e) {\n        logger.warn(ERROR_FACTORY.create(\"indexeddb-unavailable\"\n        /* AnalyticsError.INDEXEDDB_UNAVAILABLE */\n        , {\n          errorInfo: e === null || e === void 0 ? void 0 : e.toString()\n        }).message);\n        return false;\n      }\n    }\n\n    return true;\n  });\n  return _validateIndexedDB.apply(this, arguments);\n}\n\nfunction _initializeAnalytics(_x39, _x40, _x41, _x42, _x43, _x44, _x45) {\n  return _initializeAnalytics2.apply(this, arguments);\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * Analytics Service class.\r\n */\n\n\nfunction _initializeAnalytics2() {\n  _initializeAnalytics2 = _asyncToGenerator(function* (app, dynamicConfigPromisesList, measurementIdToAppId, installations, gtagCore, dataLayerName, options) {\n    var _a;\n\n    const dynamicConfigPromise = fetchDynamicConfigWithRetry(app); // Once fetched, map measurementIds to appId, for ease of lookup in wrapped gtag function.\n\n    dynamicConfigPromise.then(config => {\n      measurementIdToAppId[config.measurementId] = config.appId;\n\n      if (app.options.measurementId && config.measurementId !== app.options.measurementId) {\n        logger.warn(`The measurement ID in the local Firebase config (${app.options.measurementId})` + ` does not match the measurement ID fetched from the server (${config.measurementId}).` + ` To ensure analytics events are always sent to the correct Analytics property,` + ` update the` + ` measurement ID field in the local config or remove it from the local config.`);\n      }\n    }).catch(e => logger.error(e)); // Add to list to track state of all dynamic config promises.\n\n    dynamicConfigPromisesList.push(dynamicConfigPromise);\n    const fidPromise = validateIndexedDB().then(envIsValid => {\n      if (envIsValid) {\n        return installations.getId();\n      } else {\n        return undefined;\n      }\n    });\n    const [dynamicConfig, fid] = yield Promise.all([dynamicConfigPromise, fidPromise]); // Detect if user has already put the gtag <script> tag on this page with the passed in\n    // data layer name.\n\n    if (!findGtagScriptOnPage(dataLayerName)) {\n      insertScriptTag(dataLayerName, dynamicConfig.measurementId);\n    } // Detects if there are consent settings that need to be configured.\n\n\n    if (defaultConsentSettingsForInit) {\n      gtagCore(\"consent\"\n      /* GtagCommand.CONSENT */\n      , 'default', defaultConsentSettingsForInit);\n\n      _setConsentDefaultForInit(undefined);\n    } // This command initializes gtag.js and only needs to be called once for the entire web app,\n    // but since it is idempotent, we can call it multiple times.\n    // We keep it together with other initialization logic for better code structure.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n    gtagCore('js', new Date()); // User config added first. We don't want users to accidentally overwrite\n    // base Firebase config properties.\n\n    const configProperties = (_a = options === null || options === void 0 ? void 0 : options.config) !== null && _a !== void 0 ? _a : {}; // guard against developers accidentally setting properties with prefix `firebase_`\n\n    configProperties[ORIGIN_KEY] = 'firebase';\n    configProperties.update = true;\n\n    if (fid != null) {\n      configProperties[GA_FID_KEY] = fid;\n    } // It should be the first config command called on this GA-ID\n    // Initialize this GA-ID and set FID on it using the gtag config API.\n    // Note: This will trigger a page_view event unless 'send_page_view' is set to false in\n    // `configProperties`.\n\n\n    gtagCore(\"config\"\n    /* GtagCommand.CONFIG */\n    , dynamicConfig.measurementId, configProperties); // Detects if there is data that will be set on every event logged from the SDK.\n\n    if (defaultEventParametersForInit) {\n      gtagCore(\"set\"\n      /* GtagCommand.SET */\n      , defaultEventParametersForInit);\n\n      _setDefaultEventParametersForInit(undefined);\n    }\n\n    return dynamicConfig.measurementId;\n  });\n  return _initializeAnalytics2.apply(this, arguments);\n}\n\nclass AnalyticsService {\n  constructor(app) {\n    this.app = app;\n  }\n\n  _delete() {\n    delete initializationPromisesMap[this.app.options.appId];\n    return Promise.resolve();\n  }\n\n}\n/**\r\n * Maps appId to full initialization promise. Wrapped gtag calls must wait on\r\n * all or some of these, depending on the call's `send_to` param and the status\r\n * of the dynamic config fetches (see below).\r\n */\n\n\nlet initializationPromisesMap = {};\n/**\r\n * List of dynamic config fetch promises. In certain cases, wrapped gtag calls\r\n * wait on all these to be complete in order to determine if it can selectively\r\n * wait for only certain initialization (FID) promises or if it must wait for all.\r\n */\n\nlet dynamicConfigPromisesList = [];\n/**\r\n * Maps fetched measurementIds to appId. Populated when the app's dynamic config\r\n * fetch completes. If already populated, gtag config calls can use this to\r\n * selectively wait for only this app's initialization promise (FID) instead of all\r\n * initialization promises.\r\n */\n\nconst measurementIdToAppId = {};\n/**\r\n * Name for window global data layer array used by GA: defaults to 'dataLayer'.\r\n */\n\nlet dataLayerName = 'dataLayer';\n/**\r\n * Name for window global gtag function used by GA: defaults to 'gtag'.\r\n */\n\nlet gtagName = 'gtag';\n/**\r\n * Reproduction of standard gtag function or reference to existing\r\n * gtag function on window object.\r\n */\n\nlet gtagCoreFunction;\n/**\r\n * Wrapper around gtag function that ensures FID is sent with all\r\n * relevant event and config calls.\r\n */\n\nlet wrappedGtagFunction;\n/**\r\n * Flag to ensure page initialization steps (creation or wrapping of\r\n * dataLayer and gtag script) are only run once per page load.\r\n */\n\nlet globalInitDone = false;\n/**\r\n * Configures Firebase Analytics to use custom `gtag` or `dataLayer` names.\r\n * Intended to be used if `gtag.js` script has been installed on\r\n * this page independently of Firebase Analytics, and is using non-default\r\n * names for either the `gtag` function or for `dataLayer`.\r\n * Must be called before calling `getAnalytics()` or it won't\r\n * have any effect.\r\n *\r\n * @public\r\n *\r\n * @param options - Custom gtag and dataLayer names.\r\n */\n\nfunction settings(options) {\n  if (globalInitDone) {\n    throw ERROR_FACTORY.create(\"already-initialized\"\n    /* AnalyticsError.ALREADY_INITIALIZED */\n    );\n  }\n\n  if (options.dataLayerName) {\n    dataLayerName = options.dataLayerName;\n  }\n\n  if (options.gtagName) {\n    gtagName = options.gtagName;\n  }\n}\n/**\r\n * Returns true if no environment mismatch is found.\r\n * If environment mismatches are found, throws an INVALID_ANALYTICS_CONTEXT\r\n * error that also lists details for each mismatch found.\r\n */\n\n\nfunction warnOnBrowserContextMismatch() {\n  const mismatchedEnvMessages = [];\n\n  if (isBrowserExtension()) {\n    mismatchedEnvMessages.push('This is a browser extension environment.');\n  }\n\n  if (!areCookiesEnabled()) {\n    mismatchedEnvMessages.push('Cookies are not available.');\n  }\n\n  if (mismatchedEnvMessages.length > 0) {\n    const details = mismatchedEnvMessages.map((message, index) => `(${index + 1}) ${message}`).join(' ');\n    const err = ERROR_FACTORY.create(\"invalid-analytics-context\"\n    /* AnalyticsError.INVALID_ANALYTICS_CONTEXT */\n    , {\n      errorInfo: details\n    });\n    logger.warn(err.message);\n  }\n}\n/**\r\n * Analytics instance factory.\r\n * @internal\r\n */\n\n\nfunction factory(app, installations, options) {\n  warnOnBrowserContextMismatch();\n  const appId = app.options.appId;\n\n  if (!appId) {\n    throw ERROR_FACTORY.create(\"no-app-id\"\n    /* AnalyticsError.NO_APP_ID */\n    );\n  }\n\n  if (!app.options.apiKey) {\n    if (app.options.measurementId) {\n      logger.warn(`The \"apiKey\" field is empty in the local Firebase config. This is needed to fetch the latest` + ` measurement ID for this Firebase app. Falling back to the measurement ID ${app.options.measurementId}` + ` provided in the \"measurementId\" field in the local Firebase config.`);\n    } else {\n      throw ERROR_FACTORY.create(\"no-api-key\"\n      /* AnalyticsError.NO_API_KEY */\n      );\n    }\n  }\n\n  if (initializationPromisesMap[appId] != null) {\n    throw ERROR_FACTORY.create(\"already-exists\"\n    /* AnalyticsError.ALREADY_EXISTS */\n    , {\n      id: appId\n    });\n  }\n\n  if (!globalInitDone) {\n    // Steps here should only be done once per page: creation or wrapping\n    // of dataLayer and global gtag function.\n    getOrCreateDataLayer(dataLayerName);\n    const {\n      wrappedGtag,\n      gtagCore\n    } = wrapOrCreateGtag(initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId, dataLayerName, gtagName);\n    wrappedGtagFunction = wrappedGtag;\n    gtagCoreFunction = gtagCore;\n    globalInitDone = true;\n  } // Async but non-blocking.\n  // This map reflects the completion state of all promises for each appId.\n\n\n  initializationPromisesMap[appId] = _initializeAnalytics(app, dynamicConfigPromisesList, measurementIdToAppId, installations, gtagCoreFunction, dataLayerName, options);\n  const analyticsInstance = new AnalyticsService(app);\n  return analyticsInstance;\n}\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n/**\r\n * Returns an {@link Analytics} instance for the given app.\r\n *\r\n * @public\r\n *\r\n * @param app - The {@link @firebase/app#FirebaseApp} to use.\r\n */\n\n\nfunction getAnalytics(app = getApp()) {\n  app = getModularInstance(app); // Dependencies\n\n  const analyticsProvider = _getProvider(app, ANALYTICS_TYPE);\n\n  if (analyticsProvider.isInitialized()) {\n    return analyticsProvider.getImmediate();\n  }\n\n  return initializeAnalytics(app);\n}\n/**\r\n * Returns an {@link Analytics} instance for the given app.\r\n *\r\n * @public\r\n *\r\n * @param app - The {@link @firebase/app#FirebaseApp} to use.\r\n */\n\n\nfunction initializeAnalytics(app, options = {}) {\n  // Dependencies\n  const analyticsProvider = _getProvider(app, ANALYTICS_TYPE);\n\n  if (analyticsProvider.isInitialized()) {\n    const existingInstance = analyticsProvider.getImmediate();\n\n    if (deepEqual(options, analyticsProvider.getOptions())) {\n      return existingInstance;\n    } else {\n      throw ERROR_FACTORY.create(\"already-initialized\"\n      /* AnalyticsError.ALREADY_INITIALIZED */\n      );\n    }\n  }\n\n  const analyticsInstance = analyticsProvider.initialize({\n    options\n  });\n  return analyticsInstance;\n}\n/**\r\n * This is a public static method provided to users that wraps four different checks:\r\n *\r\n * 1. Check if it's not a browser extension environment.\r\n * 2. Check if cookies are enabled in current browser.\r\n * 3. Check if IndexedDB is supported by the browser environment.\r\n * 4. Check if the current browser context is valid for using `IndexedDB.open()`.\r\n *\r\n * @public\r\n *\r\n */\n\n\nfunction isSupported() {\n  return _isSupported.apply(this, arguments);\n}\n/**\r\n * Use gtag `config` command to set `screen_name`.\r\n *\r\n * @public\r\n *\r\n * @deprecated Use {@link logEvent} with `eventName` as 'screen_view' and add relevant `eventParams`.\r\n * See {@link https://firebase.google.com/docs/analytics/screenviews | Track Screenviews}.\r\n *\r\n * @param analyticsInstance - The {@link Analytics} instance.\r\n * @param screenName - Screen name to set.\r\n */\n\n\nfunction _isSupported() {\n  _isSupported = _asyncToGenerator(function* () {\n    if (isBrowserExtension()) {\n      return false;\n    }\n\n    if (!areCookiesEnabled()) {\n      return false;\n    }\n\n    if (!isIndexedDBAvailable()) {\n      return false;\n    }\n\n    try {\n      const isDBOpenable = yield validateIndexedDBOpenable();\n      return isDBOpenable;\n    } catch (error) {\n      return false;\n    }\n  });\n  return _isSupported.apply(this, arguments);\n}\n\nfunction setCurrentScreen(analyticsInstance, screenName, options) {\n  analyticsInstance = getModularInstance(analyticsInstance);\n  setCurrentScreen$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], screenName, options).catch(e => logger.error(e));\n}\n/**\r\n * Retrieves a unique Google Analytics identifier for the web client.\r\n * See {@link https://developers.google.com/analytics/devguides/collection/ga4/reference/config#client_id | client_id}.\r\n *\r\n * @public\r\n *\r\n * @param app - The {@link @firebase/app#FirebaseApp} to use.\r\n */\n\n\nfunction getGoogleAnalyticsClientId(_x46) {\n  return _getGoogleAnalyticsClientId.apply(this, arguments);\n}\n/**\r\n * Use gtag `config` command to set `user_id`.\r\n *\r\n * @public\r\n *\r\n * @param analyticsInstance - The {@link Analytics} instance.\r\n * @param id - User ID to set.\r\n */\n\n\nfunction _getGoogleAnalyticsClientId() {\n  _getGoogleAnalyticsClientId = _asyncToGenerator(function* (analyticsInstance) {\n    analyticsInstance = getModularInstance(analyticsInstance);\n    return internalGetGoogleAnalyticsClientId(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId]);\n  });\n  return _getGoogleAnalyticsClientId.apply(this, arguments);\n}\n\nfunction setUserId(analyticsInstance, id, options) {\n  analyticsInstance = getModularInstance(analyticsInstance);\n  setUserId$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], id, options).catch(e => logger.error(e));\n}\n/**\r\n * Use gtag `config` command to set all params specified.\r\n *\r\n * @public\r\n */\n\n\nfunction setUserProperties(analyticsInstance, properties, options) {\n  analyticsInstance = getModularInstance(analyticsInstance);\n  setUserProperties$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], properties, options).catch(e => logger.error(e));\n}\n/**\r\n * Sets whether Google Analytics collection is enabled for this app on this device.\r\n * Sets global `window['ga-disable-analyticsId'] = true;`\r\n *\r\n * @public\r\n *\r\n * @param analyticsInstance - The {@link Analytics} instance.\r\n * @param enabled - If true, enables collection, if false, disables it.\r\n */\n\n\nfunction setAnalyticsCollectionEnabled(analyticsInstance, enabled) {\n  analyticsInstance = getModularInstance(analyticsInstance);\n  setAnalyticsCollectionEnabled$1(initializationPromisesMap[analyticsInstance.app.options.appId], enabled).catch(e => logger.error(e));\n}\n/**\r\n * Adds data that will be set on every event logged from the SDK, including automatic ones.\r\n * With gtag's \"set\" command, the values passed persist on the current page and are passed with\r\n * all subsequent events.\r\n * @public\r\n * @param customParams - Any custom params the user may pass to gtag.js.\r\n */\n\n\nfunction setDefaultEventParameters(customParams) {\n  // Check if reference to existing gtag function on window object exists\n  if (wrappedGtagFunction) {\n    wrappedGtagFunction(\"set\"\n    /* GtagCommand.SET */\n    , customParams);\n  } else {\n    _setDefaultEventParametersForInit(customParams);\n  }\n}\n/**\r\n * Sends a Google Analytics event with given `eventParams`. This method\r\n * automatically associates this logged event with this Firebase web\r\n * app instance on this device.\r\n * List of official event parameters can be found in the gtag.js\r\n * reference documentation:\r\n * {@link https://developers.google.com/gtagjs/reference/ga4-events\r\n * | the GA4 reference documentation}.\r\n *\r\n * @public\r\n */\n\n\nfunction logEvent(analyticsInstance, eventName, eventParams, options) {\n  analyticsInstance = getModularInstance(analyticsInstance);\n  logEvent$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], eventName, eventParams, options).catch(e => logger.error(e));\n}\n/**\r\n * Sets the applicable end user consent state for this web app across all gtag references once\r\n * Firebase Analytics is initialized.\r\n *\r\n * Use the {@link ConsentSettings} to specify individual consent type values. By default consent\r\n * types are set to \"granted\".\r\n * @public\r\n * @param consentSettings - Maps the applicable end user consent state for gtag.js.\r\n */\n\n\nfunction setConsent(consentSettings) {\n  // Check if reference to existing gtag function on window object exists\n  if (wrappedGtagFunction) {\n    wrappedGtagFunction(\"consent\"\n    /* GtagCommand.CONSENT */\n    , 'update', consentSettings);\n  } else {\n    _setConsentDefaultForInit(consentSettings);\n  }\n}\n\nconst name = \"@firebase/analytics\";\nconst version = \"0.10.0\";\n/**\r\n * Firebase Analytics\r\n *\r\n * @packageDocumentation\r\n */\n\nfunction registerAnalytics() {\n  _registerComponent(new Component(ANALYTICS_TYPE, (container, {\n    options: analyticsOptions\n  }) => {\n    // getImmediate for FirebaseApp will always succeed\n    const app = container.getProvider('app').getImmediate();\n    const installations = container.getProvider('installations-internal').getImmediate();\n    return factory(app, installations, analyticsOptions);\n  }, \"PUBLIC\"\n  /* ComponentType.PUBLIC */\n  ));\n\n  _registerComponent(new Component('analytics-internal', internalFactory, \"PRIVATE\"\n  /* ComponentType.PRIVATE */\n  ));\n\n  registerVersion(name, version); // BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation\n\n  registerVersion(name, version, 'esm2017');\n\n  function internalFactory(container) {\n    try {\n      const analytics = container.getProvider(ANALYTICS_TYPE).getImmediate();\n      return {\n        logEvent: (eventName, eventParams, options) => logEvent(analytics, eventName, eventParams, options)\n      };\n    } catch (e) {\n      throw ERROR_FACTORY.create(\"interop-component-reg-failed\"\n      /* AnalyticsError.INTEROP_COMPONENT_REG_FAILED */\n      , {\n        reason: e\n      });\n    }\n  }\n}\n\nregisterAnalytics();\nexport { getAnalytics, getGoogleAnalyticsClientId, initializeAnalytics, isSupported, logEvent, setAnalyticsCollectionEnabled, setConsent, setCurrentScreen, setDefaultEventParameters, setUserId, setUserProperties, settings }; //# sourceMappingURL=index.esm2017.js.map","map":null,"metadata":{},"sourceType":"module"}